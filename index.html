<!DOCTYPE html>
<html>
  <head>
    <title>My Awesome Presentation</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <style type="text/css">
      @import url(https://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
      @import url(https://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic);
      @import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);

      body { font-family: 'Droid Serif'; }
      h1, h2, h3 {
        font-family: 'Yanone Kaffeesatz';
        font-weight: normal;
      }
      .remark-code, .remark-inline-code { font-family: 'Ubuntu Mono'; }
    </style>
    <script>
      document.write('<script src="http://' + (location.host || 'localhost').split(':')[0] + ':35729/livereload.js?snipver=1"></' + 'script>');
    </script>
    <!-- If this isn't working, see https://github.com/gnab/remark -->
    <script src="https://gnab.github.io/remark/downloads/remark-latest.min.js" type="text/javascript">
    </script>
  </head>
  <body onload="var slideshow = remark.create({highlightStyle: 'monokai'});">
    <textarea id="source">

# TODOs

* Get into Rayon

---


class: center, middle

# An introduction to Rust

&nbsp;

### "Technology from the past come 
### to save the future from itself"

---

# Agenda

1. What is Rust?

    * History, whirlwind feature tour via code samples

2. Safety first

    * Common pitfalls in C/C++ and how Rust guards against them

3. Parallelism in Rust

    * A look at Rayon, a library for parallel computation

---

# Rust's Origin story

* 2006 - 2010: Mozilla employee side project

--

    * "I have been writing a compiled, concurrent,
safe, systems programming language for the
past four and a half years."

    * "Spare-time kinda thing. Yeah, I got problems."

--

* 2010 - 2015: Mozilla-sponsored community-driven development

    * "Many older languages better than newer ones"

    * "We keep forgetting already-learned lessons"

    * Rust has lost more features than most languages ever gain

--

* May 2015: Stable 1.0 public release

     * Already in production at Dropbox, Chef, NPM, Xero

???

mozilla employee = Graydon Hoare, who then became BFDL

Initial Graydon presentation: http://venge.net/graydon/talks/intro-talk-2.pdf

Graydon steps down for personal reasons in Aug 2013: https://www.reddit.com/r/rust/comments/1lfoaz/graydon_hoare_steps_down_as_technical_lead_on_rust/ and https://mail.mozilla.org/pipermail/rust-dev/2013-August/005426.html

Rust is explicitly not a language to perform programming research in - it's a better C++. But what makes a better C++ wasn't clear

Older languages such as Mesa (1977), BETA (1975), CLU (1974)

Of course mozilla is a production user too.

Sample of Rust production users: https://www.rust-lang.org/en-US/friends.html

---

# "Why Oh Why? #1" (from 2010)

* C++ is well past expiration date:

    * Wildly unsafe in almost every way

        * Memory unsafe, no ownership policies, no concurrent control at all, can't even keep const values constant.

    * Heavily burdened with legacy issues

        * Absurd compilation model, weak linkage and module system, nigh impossible to write tools for.

    * Spend more time fighting its weaknesses than seems reasonable.
        * Maybe you've noticed?

???

Original motivation for Rust as described by Graydon to Mozilla employees working on Firefox.

Of course there have been a few new C++ standards since then, which have improved C++ in a few different ways

Transcribed from slides at http://venge.net/graydon/talks/intro-talk-2.pdf

---

# "Why Oh Why? #2" (from 2010)

* Most newer languages are unsuitable. One or more of:

    * JVM/CLR or similar tie-in, VM/FFI burden

    * Complex GC + pointer-heavy = poor memory use

    * "Different paradigm" (hard to find talent for, comprehension barrier, unpredictable)

    * "Script language" (few types or static checks)

    * Mostly ignore isolation, interference, concurrency

---

class: center, middle

# A whirlwind tour of features

???

will only cover current stable features

only a subset, leaving out lots of interesting bits because of lack of time

point is to give a flavour of the language

---

# C-like syntax, with the good parts of FP

```rust
fn factorial_loop(n: u32) -> u32 {
    // Variables are declared with `let`.
    // The `mut` keyword allows these variables to be mutated.
    let mut result = 1;
    for i in 2..n+1 { // The lower bound is inclusive, the upper bound exclusive.
        result *= i;
    }
    return result;
}

fn factorial_recursive(n: u32) -> u32 {
    if n <= 1 {
        1 // no need for `return` if it's the final expression
    } else {
        n * factorial_recursive(n - 1)
    }
}

fn factorial_iterator(n: u32) -> u32 {
    // |accum, next| defines an anonymous function.
    // Optimizations like inline expansion reduce the range and fold
    // to have performance similar to factorial_iterative.
    (1..n + 1).fold(1, |accum, next| accum * next)
}
```

???

* Numbers can be signed or unsigned
  * You know the bit width of your numbers!
* Immutable variables by default
* Can make any variable mutable if you own it
* Expression-oriented: a semicolon turns an expression into a statement
  * Final expression of a fn is the return value of that fn
  * Means `return` is only needed for early returns
* Anonymous function benefits from expression-ness
  * Also can pass in a regular function there
  * Function can close over data in scope (i.e. closure)

---

# Structs for data, Traits for behaviour

```rust
struct Point {
    x: i32,
    y: i32,
}

trait OnGrid {
    fn calc_origin_dist(&self) -> f64;
}

impl OnGrid for Point {
    fn calc_origin_dist(&self) -> f64 {
        ((self.x.abs() + self.y.abs()) as f64).sqrt()
    }
}

#[test] // attribute indicates this is a unit test
fn can_calc_point_origin_dist() {
    assert_eq!(Point { x: 2, y: 2 }.calc_origin_dist(), 2.0);
}
```

???

Structs are pure data

Traits are ~ interfaces, inspired by haskell's type classes

You implement traits to add data to your objects

Test framework is built in via the test attribute

Macros always end in !, are AST-based, and are hygenic

assert_eq panics the thread if there's no equality

2.0 is type inferred to be an f64.

rust type inference is ~ good enough to infer your whole program's types, but function signatures must have types - helps aid readers and improves grepping the code

rust doesn't have exceptions - the whole thread panics if there's an irrecoverable error (though you can "catch" that for specific cases)

---

# Operator overloading & modules

```rust
use std::ops::Add;

#[derive(Debug, Eq, PartialEq)]
pub struct Point {
    pub x: i32,
    pub y: i32,
}

impl Add for Point {
    type Output = Point; // "associated type"

    fn add(self, other: Point) -> Self::Output { // or "-> Point"
        Point {
            x: self.x + other.x,
            y: self.y + other.y,
        }
    }
}

#[cfg(test)]
mod tests {
    #[test]
    fn can_add_points() {
        assert_eq!(Point { x: 3, y: 3 },
            Point { x: 1, y: 0 } + Point { x: 2, y: 3 });
    }
}
```

???

Add is an existing trait that we implement; compiler ties it to +

Compiler can implement certain traits automatically

We implement a debug string representation and equality

When we implement the Add trait we can use + with our data structure

Associated type is a form of generics support, like C++ templates (won't get too heavily into that here but can also accept a generic input E where E implements some trait T, in which case the compiler monomorphises )

`mod tests` starts a module - modules are compiled incrementally and used for encapsulation, and no header files means no compile time explosions

`#[cfg(test)]` is for conditional compilation support

have to mark functions and structs `pub` to use them outside a module

pub structs have hidden fields which can be exposed by pub

---

# True systems programming language

* No garbage collection
  * variables have lifetimes (~= scope)
  * deallocated ("dropped") when out of scope

* Explicit stack vs heap allocation

```rust
let a: Point = Point { x: 0, y: 0 }; // on stack
let b: Box<Point> = Box::new(Point { x: 0, y: 0 }); // on heap
let c: Box<_> = Box::new(Point { x: 0, y: 0 }); // on heap
let d = Box::new(Point { x: 0, y: 0 }); // on heap
```

* Compiles to LLVM IR -> many optimizations come for free

* Supports Win (MingGW & VS) + OSX + Linux, 32 & 64-bit
    * Also lower tier support for arm, musl, powerpc, wasm + many more

* Std lib is optional, suitable for writing an operating system from scratch

* Supports custom allocators; `jemalloc` or `malloc()`+`free()` by default

???

no GC but can put vars into an Rc (or Arc) to get reference counting, optionally thread-safe

when variables are dropped they can have destructor-like code run

when something is in a `Box`, the compiler will automatically dereference it, so no syntactical overhead on call sites

you can leave off the types of the variables, which i've done for `c` and `d`

the big three platforms have first class support

other platforms have lower tier support

optional stdlib means can write OS or use for embedded systems

custom allocators - will use jemalloc for a freestanding binary or malloc/free if writing a lib, but either choice can be overwritten

---

# Heaps more good stuff

* Language features: pattern matching, `const`s, macros, Universal Function Call Syntax (UFCS), slicing syntax, lazy iterators, built-in tuples, newtype structs, etc

* Package manager (`cargo`) to manage dependencies and invoke `rustc`

* Good FFI: easy to call C, easy to be called from C, easy to pass data

* Proper unicode string support (codepoints & graphemes), UTF-8 internally

* Focus on high quality documentation & teaching newbies

* Ridiculously helpful community

* Open RFC-based development process with strong leadership team

* 6 weeks per (backwards compatible) release; stable & beta (& nightly)


???

UFCS = universal functional call syntax, i.e. can call a method on a trait by item.method() or by trait::method(item) (or something like that - I always forget the syntax)

Cargo is package and dependency management done right - embrace semver, but allow dependencies to be locked down, act as a thin wrapper around rustc without tying rustc to cargo

FFI is built in, has keywords to make it easy. Can choose from a few different memory layouts for your structs. Working on C++ interop.

Strings are stored as UTF-8 but only validated at the edges of your app. Rust makes you choose whether you want byte, codepoint or grapheme based indexing, and panics if you index into half a codepoint

Documentation is great, in fact most of these slides are adapted from official documentation or blog posts

Community tries hard to not be dismissive of other languages and accepting of newbies

Anyone can write an RFC to propose evolution of the language, tooling or community in a certain direction; core team gathers feedback and makes final decision.

Features and bug fixes come regularly; Rust was highly unstable back in 2014 but very stable now. Worst I've had since 1.0 is dealing with new lints and warnings, which is great.

---

class: center, middle

# Let's talk about concurrency

## and some related safety problems

---

# Typical correctness & concurrency problems

* Mistakes while pointer twiddling (mostly C)

* Null pointers

* Exception safety (C++)

* Dangling pointer / use after free (C/C++)

* Failure to realise memory is reallocated (C/C++)

    * E.g. reuse an iterator after `std::vector::push_back`

* Threads with shared mutable memory -> easy data races

* Not holding a lock (or holding the wrong one)

???

Pointer twiddling isn't as common as in C but if you fuck it up then your program will still behave badly

Not all concurrency problems but they'll all cause your program to be incorrect

Apologies for incorrect terminology, I have minimal C++ experience

---

# Rust: pointer twiddling explicitly delineated

If you mess with raw memory or break the rules without permission...

```rust
let x = 5;
let raw = &x as *const i32;
println!("raw points at {}", *raw); // doesn't work
```

Then you get an error:

```c
$ cargo build
error[E0133]: dereference of raw pointer requires unsafe function or block
  --> src/main.rs:25:38
   |
24 |         println!("raw points at {}", *raw);
   |                                      ^^^^ dereference of raw pointer

```

Instead you need to use an unsafe block if you need an escape hatch:

```rust
let x = 5;
let raw = &x as *const i32;
println!("raw points at {}", unsafe { *raw });
```

`unsafe {}` serves as an audit boundary/headsup: "*Attention code reviewers!*"

???

Ordinarily you write "safe Rust"

Unsafe blocks serve to delineate things which are unsound according to the type system, and content of them is called "Unsafe Rust"

E.g. Raw memory access, calling C functions, casting from one type to a completely different one, etc

Useful for performance, or when you are really really certain that what you're doing is fine even though you can't prove it

Lets you trade off safety for performance; and if your program crashes, you know it's due to an unsafe block somewhere

---

# Rust: no null pointers

```rust
pub enum Option<T> { None, Some(T) } // in stdlib

fn divide(numerator: f64, denominator: f64) -> Option<f64> {
    if denominator == 0.0 { None } else { Some(numerator / denominator) }
}

let result: Option<f64> = divide(2.0, 3.0);

// Pattern match to retrieve the value
match result {
    // The division was valid
    Some(x) => println!("Result: {}", x),
    // The division was invalid
    None    => println!("Cannot divide by 0"),
}

// OR use `if let` syntax if you don't care about the other case
if let Some(x) = result {
    println!("Result: {}", x);
}

// OR use "combinators" (functions) defined on `Option` if you need to keep going
result.and_then(|x| divide(x, 2.0)) // can fail (return None), so use `and_then()`
    .map(|half_x| half_x + 1.0) // cannot fail (returns raw value) so use `map()`
    .map(|half_x_plus_1| println!("Result/2 + 1: {:?}", half_x_plus_1));
```

???

Safe Rust code has no null

Instead it uses the Option type, similar to the Maybe monad in Haskell

Means you can't miss a null check when you should have one, and don't need to insert them "just to be safe"

Enums in Rust are tagged unions

Even better, this (and other enum types of similar shape) is guaranteed to be optimised out to a null pointer under the covers, so no performance penalty

Similar to the proposed http://en.cppreference.com/w/cpp/experimental/optional

---

# Rust: no exceptions: error values and panics

```rust
pub enum Result<T, E> { Ok(T), Err(E) } // in stdlib

pub enum Error { // simplification of std::io::Error
    NotFound, PermissionDenied, ConnectionRefused,
    ConnectionReset, ConnectionAborted, NotConnected, // etc
}

fn parse_boggle_board(board_path: &String) -> Result<io::Error, BoggleBoard> {
  let board_file = BufReader::new(try!(File::open(board_path)));
  // (you'd actually read from the file here)
  Ok(BoggleBoard::new(/* construct using data read from file */))
}
```

* Result has similar combinator functions as `Option`: `and_then()`, `map()`, etc

    * And same again to work with error side: `err_map()`, etc

* OR: a thread can panic, which unwinds the stack, calling all "destructors"

    * safe-to-unwind generally only a concern for unsafe FFI code
    * can be detected by a controlling thread or (rarely done) same thread

* OR: program can hard abort, e.g. when unable to heap allocate memory

???

Rust has no exceptions but instead has a Result type

`Result` type captures either an error of some type, or a successful result.

Similar to Either in Haskell or Scala - it's the standard disjunction type.

So instead of a function signature where you have no idea if it can fail (assuming you're not using Java checked exceptions or C++ exception specifications), you know if a function is expected to be able to fail.

Alternatively, for irrecoverable errors where you really want to explode, you can panic the whole thread.

For example, arithmetic overflow or underflow causes panic by default in a debug build (is very controllable), and indexing into a vector is always bounds checked (unless unsafe) and failing that check causes a panic.

unwinding panics can also be "caught" in same thread - only for FFI really: https://doc.rust-lang.org/std/panic/fn.catch_unwind.html Normally you'd use Result

Since panic causes unwinding and can be caught, it's similar to unwinding due to exceptions...

But because Rust handles deallocation of resources via RAII on steroids (see next slide), safe Rust code is automatically unwinding-safe.

More info:

* https://doc.rust-lang.org/book/error-handling.html
* https://doc.rust-lang.org/nomicon/unwinding.html
* https://doc.rust-lang.org/nomicon/exception-safety.html
* https://doc.rust-lang.org/nomicon/poisoning.html
* http://huonw.github.io/blog/2016/04/myths-and-legends-about-integer-overflow-in-rust/

---

# Rust: types guard against use after free

```rust
let a = Box::new(42i32);
let b = a; // move semantics by default, so `a` moves to `b`
println!("a is {}", a);
drop(b); // similar to explicit free() - is not normally done in Rust
println!("b is {}", b);
```

```c
$ cargo build
error[E0382]: use of moved value: `a`
  --> src/main.rs:52:29
   |
51 |         let b = a; // move semantics by default, so `a` moves to `b`
   |             - value moved here
52 |         println!("a is {}", a);
   |                             ^ value used here after move
   |
   = note: moved because `a` has type `Box<i32>` & does not implement `Copy` trait

error[E0382]: use of moved value: `b`
  --> src/main.rs:54:29
   |
53 |         drop(b); // similar to explicit free() - is not normally done in Rust
   |              - value moved here
54 |         println!("b is {}", b);
   |                             ^ value used here after move
   |
   = note: moved because `b` has type `Box<i32>` & does not implement `Copy` trait
```

???

i32 suffix is literal syntax to include type of the integer explicitly in the literal, not important

Rust has move semantics by default - nice because it means you don't get exceptions when assigning

Since Rust tracks the lifetimes of everything and knows when things get deallocated, it can tell when you're about to reference bad memory

If our type that we were trying to move implemented the special `Copy` trait as hinted, then Rust would know it can do a byte for byte copy

Here 42 implements Copy but Box doesn't (otherwise it'd be way to easy to use a ton of heap memory)

To not use move semantics, use `let b = a.clone()` - that fixes first error by cloning whatever is in the box (a number, for which clone is a byte for byte copy) and allocating it on the heap

OR "borrow" (aka take a reference, like a pointer) `a`: `let b = &a`

Obviously to fix second error, don't call drop() - let the variable go out of scope so that Rust automatically deallocates it as part of returning from the function (which is what you normally do)

---

# Taking it a step further: "borrowing"

In C++ you have `unique_ptr` which sounds similar to Rust's ideas, however...

```C++
    unique_ptr<int> orig(new int(5));
    cout << *orig << endl;
    auto stolen = move(orig);
    cout << *orig << endl; // undefined behaviour! /me waits for time travel :)
```

Rust takes this a step further by explicitly encoding the idea of taking a reference to a uniquely owned variable without moving it.

When pointer is pointing at a variable `a`, *`a` is borrowed*.

```rust
let a: i32 = 42;
let b: &i32 = &a; // now `b` can't "live longer"" than `a`
                  // `a` also cannot be mutated while `b` is "alive"
                  // (`a` isn't `mut a` so wouldn't be mutable anyway)
let c: &i32 = &a; // multiple borrows of same variable are fine
let d: &i32 = b;  // borrows can also be copied without any problem
```

???

Borrowing is one of the central ideas of Rust so make a small detour to explain how it's different to unique_ptr

Borrowing rules are enforced by the borrow checker; it's painful when learning Rust & is responsible for Rust's reputation of having a steep learning curve.

But once you understand the rules and learn best practice program design, it's responsible for avoiding whole classes of bugs related to pointer aliasing, and it turns out it makes a bunch of other things better too.

---

# Rust: no "mutation reallocs memory" problem

In C++, reusing iterator after a `std::vector::push_back` causes undefined behaviour.

In Rust, it won't compile, because a borrowed variable cannot be mutated while a borrowing is alive!

```rust
let mut vec = Vec::new(); // a growable vector, like in C++
vec.push(1); // a push can cause a reallocation + move
vec.push(2);
for &i in vec.iter() { // `.iter()` returns an iterator
  vec.push(i); // duplicate each entry - this would be unsafe in C++!
}
```

```rust
$ cargo build
error[E0502]: cannot borrow `vec` as mutable because it is also immutably borrowed
  --> src/main.rs:69:9
   |
68 |         for &i in vec.iter() {
   |                   --- immutable borrow occurs here
69 |         vec.push(i);
   |         ^^^ mutable borrow occurs here
70 |         }
   |         - immutable borrow ends here
```

???

What actually happens under the covers is that Rust allows immutable borrows (as on previous slide) but also allows mutable borrows.

The rule is that you can't have a mutable borrow unless

1. you own that variable
2. the variable is `mut`
3. there are no other borrows

Any borrow, including methods defined on a trait implementation for a struct, can either:

1. consume the whole struct (take ownership, struct can't be used afterwards - good for builders - unless the struct is returned later)
2. borrow the struct immutably (the norm for non-mutating methods)
3. borrow the struct mutably (norm for mutating methods)

Since `.iter()` causes a borrow, we can't '
 because the borrow checker prevents mutation while the iterator holds a reference to the underlying data structure.

More:

* Rules of borrowck: https://www.reddit.com/r/rust/comments/5ny09j/tips_to_not_fight_the_borrow_checker/dcf9khl/

---

# Rust: data race protection via borrowck

> "Shared mutable memory is the root of all evil"

### Modern languages solve by either:

* no *shared* memory: force threads to send messages to each other

* no *mutation* of memory: force threads to take copies of data

### Rust says: "no *shared mutation* of memory"

Borrowing rules we just covered statically guarantee at compile time that **no thread can mutate data while another thread can access that same data**.

???

Borrowck is the colloqial term for the borrow checker - named after the phase of the compilation process AFAIK.

Channel based approachs like Go and actor systems like Erlang and Akka force threads to send memory to each other

Other languages like Haskell, Scala force your data to be immutable and copied

Rust identifies that neither is inherently bad and each approach has its upsides and downsides, so allows using them together.

Put another way: shared memory XOR mutation of aforementioned memory.

The way I heard it told was that this was almost an accidental consequence of trying to solve other kinds of problems (use after free, mutation): Rust designers realised that the borrow checker helps here too!

More: https://doc.rust-lang.org/beta/nomicon/races.html

---

# Rust: borrowck forces holding correct locks

```rust
// (simplification of stdlib mutex - stdlib is more ergonomic)

// create a new mutex
fn mutex<T: Send>(t: T) -> Mutex<T>;

// acquire the lock
fn lock<T: Send>(mutex: &Mutex<T>) -> MutexGuard<T>;

// access the data protected by the lock
fn access<T: Send>(guard: &mut MutexGuard<T>) -> &mut T;


// example usage
fn use_lock(mutex: &Mutex<Vec<i32>>) {
  // acquire the lock, taking ownership of a guard;
  // the lock is held for the rest of the scope
  let mut guard = lock(mutex);

  // access the data by mutably borrowing the guard
  let vec = access(&mut guard);

  // vec has type `&mut Vec<i32>`
  vec.push(3);

  // lock automatically released here, when `guard` is destroyed
}
```

???

In most languages it's easy to hold the wrong lock (or not hold a lock when you should be holding one)

Usually only documentation guards against holding no lock or the wrong lock

so locks get a bad rap, but sometimes you know you need a lock

In Rust, a mutex is conceptually like a container which holds the data that it protects, so it's generic over a type

Successfully acquiring the lock gets you a MutexGuard

From the MutexGuard, you can access the data protected by the mutex

But crucially, the resulting T cannot live longer than the MutexGuard (eachg borrow has a lifetime, and the output borrow is assumed to live at most as long as the input-ted data could), and the lock is only released when the guard is destroyed.

So it's not possible to use the lock incorrectly without getting a compiler error, and it's not possible to access the data without holding the lock.

More:
* https://blog.rust-lang.org/2015/04/10/Fearless-Concurrency.html
* http://softwareengineering.stackexchange.com/questions/317873/how-does-rust-diverge-from-the-concurrency-facilities-of-c

---

# Rust: has channels for message passing too

```rust
use std::thread;
use std::sync::mpsc::channel;

// Create a shared channel that can be sent along from many threads
// where tx is the sending half (tx for transmission), and rx is the receiving
// half (rx for receiving).
let (tx, rx) = channel();
for i in 0..10 {
  let tx = tx.clone();
  thread::spawn(move|| { // spawn a thread then send the thread number
    tx.send(i).unwrap(); // returns a Result; unwrap() is quick & dirty handling
  }); // spawn() returns a handle we could (but don't) use to check for panic
}

for _ in 0..10 { // wait for all threads to send their numbers
  let j = rx.recv().unwrap(); // again, dirty dirty error handling
  assert!(0 <= j && j < 10);
}
```

???

Initially had green threads and only channels built into library to communicate (like Go)

Now native threads (green threads required a runtime which conflicted with Rust being suitable for embedding into other applications)

`move` keyword before the closure's double pipe (`||`) indicates that rather than treat references to variables outside the closure as references, those variables should instead be moved into the closure, such that they're owned by the closure (rather than their original owning context).

As an aside, we could be checking whether or not each thread panics here, but we don't because we're talking about channels

Nice: channels are implemented as library code - can get a replacement channel library which supports multi producer and multi consumer, and it's just as ergonomic to use

Can even handle application signals via `chan-signal`, which is super useful if you've ever read up on what you can do during signal handling (spoiler: not much)

More:

* https://static.rust-lang.org/doc/master/std/sync/mpsc/index.html
* https://github.com/BurntSushi/chan
* https://github.com/BurntSushi/chan-signal

---

# Rust: thread safety checked by compiler

### Q: Can I send a variable between threads?

A: Only if it implements the `Send` trait, which is almost all primitive types and types composed thereof.

But, for example, in SDL, the thread that creates the window must be the one that handles the events. The `SdlWindow` struct would not implement `Send`.

### Q: Can I access a shared variable from another thread?

A: Only if it implements the `Sync` trait, which is any type `T` where `&T` is safe to pass between threads without undefined behaviour, which is most types.

But, for example, the `Rc` smart pointer (implements reference counting) does not use atomics to count references & so does not implement `Sync`.<br>
You would use an `Arc` (Atomic Rc) to share a reference count between threads.

???

I lied a little on the last slide

You can't send anything you like across channels

Only structs which are so-called `Send` can be sent across channels or moved to another thread. That's useful when you're wrapping a library which itself isn't thread safe.

And only structs which implement `Sync` can be accessed from another thread.

Compiler auto implements these traits for all eligible structs, which is most struckts.

And if you know better than the compiler, you can opt a struct in or out (requires unsafe code, because it's an escape hatch)

More:

* https://doc.rust-lang.org/book/concurrency.html
* https://doc.rust-lang.org/std/marker/trait.Send.html
* https://doc.rust-lang.org/std/marker/trait.Sync.html
* https://doc.rust-lang.org/nomicon/send-and-sync.html
* https://doc.rust-lang.org/std/sync/atomic/

---

class: center, middle

## thanks!

# Questions?

---

## A code sample

```rust
fn parse_boggle_board(board_path: &String) -> io::Result<BoggleBoard> {
    use std::io::BufReader;
    use std::io::prelude::*;
    use std::fs::File;

    print!("Parsing board from {}", board_path);
    let board_file = BufReader::new(try!(File::open(board_path)));
    let mut width = None;
    let mut height = None;
    let mut letters = Vec::with_capacity(10000);
    for line_or_err in board_file.lines() {
        let line = line_or_err.unwrap(); // explode if error
        if line.len() == 0 {
            break; // end of file
        }
        for s in line.split(' ').filter(|s| s.len() != 0) {
            if width.is_none() {
                width = Some(s.parse().unwrap());
            } else if height.is_none() {
                height = Some(s.parse().unwrap());
            } else {
                letters.push(s.bytes().nth(0).expect("first char !present"));
            }
        }
    }
    Ok(BoggleBoard::new(width.expect("board width must be specified"),
                        height.expect("board height must be specified"),
                        letters))
}
```

---

```rust
    fn main() -> i32 {
      let my_homie: String = "Caspar".to_owned();
      println!("{} was here", my_homie);
    }
```
    </textarea>
  </body>
</html>
